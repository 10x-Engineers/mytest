<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lane &mdash; Ara 1.0 documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Dispatcher and Sequencer" href="dispatcher_sequencer.html" />
    <link rel="prev" title="Vector Load Store Unit" href="vlsu.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Ara
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="ara.html">Ara</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="cva6.html">CVA6</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="vu1_0.html">Vector Unit 1.0</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="vlsu.html">Vector Load Store Unit</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Lane</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ara-vector-register-file">Ara Vector Register File</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="dispatcher_sequencer.html">Dispatcher and Sequencer</a></li>
<li class="toctree-l3"><a class="reference internal" href="sldu.html">Slide Unit</a></li>
<li class="toctree-l3"><a class="reference internal" href="masku.html">Mask Unit</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Ara</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="ara.html">Ara</a> &raquo;</li>
          <li><a href="vu1_0.html">Vector Unit 1.0</a> &raquo;</li>
      <li>Lane</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/lane.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="lane">
<h1>Lane<a class="headerlink" href="#lane" title="Permalink to this headline">¶</a></h1>
<div class="section" id="ara-vector-register-file">
<h2>Ara Vector Register File<a class="headerlink" href="#ara-vector-register-file" title="Permalink to this headline">¶</a></h2>
<p>The Vector Register File (VRF) of Ara is implemented using a set of single ported (1RW) memory banks. The width of each bank is 64-bits which is the same as the width of the datapath of each lane. There are eight banks per lane resulting in eight single ported memory banks per lane. In the RVV ISA there are 32 vector registers. The size of each vector register, in bits, is implementation dependent (minimum = 128 bit).  Let’s look at the size of VRF by using an example.</p>
<p>Size of Vector register  (VLEN) = 4096 bit</p>
<p>Size of Vector Register File = 4096 * 32 = 217 bits = 16 KB</p>
<p>Number of Lanes in Ara can vary from 1 to 16 (implementation dependent). So for a 4 lane system the VRF will be divided into 4 lanes with 4KB of memory per lane.</p>
<a class="reference internal image-reference" href="_images/VRFSize.png"><img alt="VRF Size pre Lane" class="align-center" src="_images/VRFSize.png" style="width: 322.0px; height: 152.0px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Benefits of splitting VRF across lanes:</p>
<ul class="simple">
<li><p>As lanes are our processing elements so most computation constrained within one lane makes hardware implementation easy.</p></li>
<li><p>Removes the dependency of the execution units  on the number of lanes which makes Ara scalable.</p></li>
<li><p>As VRF is internal to the lane routing between VRF and lane execution logic is simplified.</p></li>
</ul>
<div class="section" id="division-of-vrf-into-banks">
<h3>Division of VRF into Banks<a class="headerlink" href="#division-of-vrf-into-banks" title="Permalink to this headline">¶</a></h3>
<p>As indicated earlier the portion of VRF inside a lane is further divided into eight 64-bit wide banks. Each bank is implemented using a single-ported SRAM memory. Being a single ported memory it has only one address port for both reads and writes. In steady state, under worst case conditions, 5 banks are accessed simultaneously in order to support predicated multiply-accumulate instructions (which require 3 source registers plus the mask register resulting in 4 reads, and one destination register -resulting in a single write).</p>
<img alt="VRF Size per Banks" class="align-center" src="_images/VRFPerLanePerBank.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Continuing with the earlier example, where each of the four lanes has 4KB of memory, each lane will as such have 8 banks of 512B (4096B / 8 =  512B) memory. Given that each bank is 64-bits wide there will be 64 (512B/8B = 64) 8B wide addressable locations within each bank.</p>
<p>Since each lane has  4KB of VRF memory the address bus, going to each lane,  will be 12-bits wide. Since there are 8 banks within a lane the least significant 3 bits of the address are used for addressing the 8 banks and the remaining 9-bits are used to address the byte within the bank. Of these remaining 9-bits, 6-bits are used to address 1-of-the-64 64-bit locations within the bank and the remaining 3 bits of the address are used to address the individual byte within the 64-bits.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/addressPerLane.png"><img alt="Address distribution inside a lane" src="_images/addressPerLane.png" style="width: 328.40000000000003px; height: 77.60000000000001px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="translating-vector-register-number-to-sram-memory-bank">
<h3>Translating Vector Register Number to SRAM memory Bank<a class="headerlink" href="#translating-vector-register-number-to-sram-memory-bank" title="Permalink to this headline">¶</a></h3>
<p>Vector register number fields ranging in value from 0 to 31 (5-bits) are present in the instruction. They are decoded and used to determine the starting address of that vector register in the VRF memory. Within a lane the vector registers are stored as a contiguous set of bytes. The register number (vid) is multiplied by a factor which is equal to the number of bytes in a single vector register divided by the number of lanes. The resulting number gives the starting address of the vector register in the VRF memory.</p>
<p>For normal cases the starting address of every vector register is a multiple of 8 given that the multiplying factor that is used is a  power of 2 and  greater than or equal to 8. For our continuing example this factor is equal to 128 [(4096/8)/4].  In some cases where VLEN is small e.g.128, and number of lanes are high e.g. 16 this is not true.  So if the address is a multiple of 8  then the least significant three bits of the address are always 0.  As indicated earlier the least significant 3 bits of the address are used to select the bank. As such every vector register has its first element (its starting point) in the first bank i.e., bank 0 and this will cause bank conflicts which are discussed later.</p>
<p>Continuing with our example the following table gives the starting address in the VRF memory for all 32 vector registers. As can be seen the last nibble of every address is 0 implying that the last 3 address bits are always 0 and as such always pointing to bank 0.</p>
<p>This arrangement causes bank conflicts because banks are composed of single ported memories and as such only a single request to read or write an operand can be sent to a bank. However functional units can request multiple operands simultaneously and as such need to access the same bank at the same time causing bank conflicts.</p>
<p>To resolve bank conflicts Ara uses a weighted round robin priority arbiter per bank. Mask register (v0) has the highest priority, followed by reading of operands A, B, C, and then writing a destination register.</p>
</div>
<div class="section" id="organization-of-elements-in-vector-register-file">
<h3>Organization of Elements in Vector Register File<a class="headerlink" href="#organization-of-elements-in-vector-register-file" title="Permalink to this headline">¶</a></h3>
<p>Elements of a  vector register are mapped to consecutive lanes in the VRF. Each lane’s  datapath width is 64 bits which matches the width of an individual register file bank. The  figure below shows 4 lanes, numbered 0-3  with each lane having 8 bytes (64 bits) and the consecutive bytes numbered 0 - 1F. Since there are functional units present in each lane, groups of elements can be processed in parallel. For example if we have four 64-bit elements and four lanes then each element is placed in a different lane shown by the numbers 0-3 below. All 4 of these elements can be accessed simultaneously from the VRF and can be operated upon in parallel.</p>
<div class="figure align-center">
<img alt="Elements split across lanes" src="_images/VLEN512_SEW64_Lane4.png" />
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Continuing with the previous arrangement across lanes, elements within a single lane are also arranged in an order such that when the element width changes the mapping between some of the elements and lanes remains the same. Due to this, the mapping between consecutive bytes in a lane and consecutive bytes of an element is not the same. This is resolved by using shuffle logic described in the next section.</p>
<p>As an example with a vector length of 256B (2048-bits) and 4 lanes each of which are  64-bits wide the mapping of bytes for various sizes of SEW are shown below:</p>
<div class="figure align-center">
<img alt="Organiation of elements in Lanes with variation in SEW" src="_images/elem_lane_organization.png" />
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>For the first case (SEW = 64) the arrangement is simple and obvious. Each 64-bit element is mapped into a different lane and the bytes of each element are contiguously stored within the lane. For the second case (SEW = 32) elements 0, 1, 2 and 3 are mapped in the lower half (32-bit) of lane 0 through lane 3. Element 4 then gets mapped to the upper half of lane 0 and so on until element 7 gets mapped to the upper half of lane 3. It is important to note that the least significant byte of  elements 0, 1, 2 and 3 for both cases of SEW are mapped to the same byte location within the corresponding lanes.  This process continues to be repeated for the remaining values of SEW.</p>
<p>In the case of SEW = 16 and 8 there is an additional thing to observe. When we start from lane 0 to start assigning the first byte of a new element we also observe which half of the lane (upper or lower 32-bits) the last element in the lane was assigned.  For the new assignment we pick the half which was not used the previous time. So in the case of SEW = 16  when it comes time to assigning element 8 it is placed in Lane 0’s byte position 2 (lower half of lane 0) and not byte position 6 (upper half of lane 0)  since the last element assigned in lane 0, element 4, was assigned in byte position 4 (upper half of lane 0).</p>
<p>The above arrangement of elements and their corresponding bytes in the VRF is constrained within the lane. Data outside the lane i.e in memory, is arranged with bytes packed simply from the least-significant byte to the most-significant byte in increasing memory addresses. As such when data is moved between the memory and the VRF bytes get shuffled/de-shuffled to match the appropriate required ordering. These two ordering of elements and bytes is referred to as Lane Organization of bytes and Natural Packing of bytes.</p>
<p><strong>Lane Organization:</strong> The manner in which elements and their corresponding bytes are stored in the VRF as discussed above.</p>
<p><strong>Natural Packing:</strong> The elements and bytes packed in memory with the least-significant bye to the most-significant byte in increasing memory addresses.</p>
</div>
<div class="section" id="shuffle-logic">
<h3>Shuffle Logic<a class="headerlink" href="#shuffle-logic" title="Permalink to this headline">¶</a></h3>
<p>The shuffle/de-shuffle logic sits between the memory subsystem and the VRF as shown below. When data is moved from memory to the VRF (via a load instruction) it gets shuffled from the Natural Packing arrangement to the Lane Organization arrangement. Similarly When data is moved from VRF to memory (via a store instruction) it gets de-shuffled from the  Lane Organization to the Natural Packing arrangement.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/shuffle_interconnect.png"><img alt="Shuffle logic interconnect between memory and VRF" src="_images/shuffle_interconnect.png" style="width: 312.8px; height: 104.80000000000001px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>The mapping of bytes from Natural Packing to Lane Organization for 4 lanes and SEW of 16 is shown in the figure below.  For element 0, byte indices are the same, 0 &amp; 1, for Natural Packing and Lane Organization. Element 1 is mapped  to byte index 8 in the VRF with its two bytes in indices 8 &amp; 9 in the VRF. Shuffle logic takes the sequential bytes from memory as shown in the natural Packing row and converts it into the Lane Organization arrangement as shown in the Lane Organization row. De-shuffle logic does the opposite. These mappings are shown with arrows in the diagram for some of the elements.</p>
<div class="figure align-center">
<img alt="Shuffle logic for SEW=16" src="_images/shuffling_logic_SEW16.png" />
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>The arrangement of  the shuffle/de-shuffle logic is a function of SEW. This means that when a vector is moved between Memory and the VRF or vice versa, bytes get shuffled/de-shuffled based on the value of the vector’s SEW (or EEW). As such in addition to the bytes of the vector being stored in the VRF it also gets tagged, in hardware, with its SEW (or EEW.) This tag is subsequently used by the shuffle/de-shuffle logic when data is moved around.</p>
<div class="figure align-center">
<img alt="Shuffling logic with variation of sew" src="_images/shuffling_logic_vary_sew.png" />
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>Note:</strong> Next two section are pending for review. Thanks</p>
</div>
<div class="section" id="mapping-of-elements-to-vector-register-file">
<h3>Mapping of elements to Vector Register File<a class="headerlink" href="#mapping-of-elements-to-vector-register-file" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="vector-register-file-and-operand-deliver-interconnect">
<h3>Vector Register File and Operand-Deliver Interconnect<a class="headerlink" href="#vector-register-file-and-operand-deliver-interconnect" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="vlsu.html" class="btn btn-neutral float-left" title="Vector Load Store Unit" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="dispatcher_sequencer.html" class="btn btn-neutral float-right" title="Dispatcher and Sequencer" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Sharafat Hussain.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>